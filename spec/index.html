<!DOCTYPE html>
<html lang="en">
<head>
<meta content="text/html; charset=utf-8" http-equiv="content-type" />
<title>RDF Dataset Canonicalization</title>
<script class="remove" src="https://www.w3.org/Tools/respec/respec-w3c"></script>
<script src="common/common.js" class="remove" defer></script>
<script class="remove" src="common/biblio.js"></script>
<script class="remove">
//<![CDATA[
  var respecConfig = {
    localBiblio:          rch.localBiblio,
    specStatus:           "ED",
    copyrightStart:       "2010",
    edDraftURI:           "https://w3c.github.io/rdf-canon/spec",

    // the specification's short name, as in http://www.w3.org/TR/short-name/
    shortName:            "rdf-canon",
    subtitle:             "A Standard RDF Dataset Canonicalization Algorithm",
    // if you wish the publication date to be other than today, set this
    // publishDate:  "2009-08-06",

    github: "https://github.com/w3c/rdf-canon/",
    edDraftURI: "https://w3c.github.io/rdf-canon/spec/",
    // editors, add as many as you like
    // only "name" is required
    editors:  [
      { name:       "Dave Longley",
        url:        "https://digitalbazaar.com/author/dlongley/",
        w3cid:      "48025",
        company:    "Digital Bazaar",
        companyURL: "https://digitalbazaar.com/" },
      { name:       "Gregg Kellogg",
        url:        "https://greggkellogg.net/",
        w3cid:      "44770" },
      { name:       "Dan Yamamoto",
        url:        "https://github.com/yamdan",
        w3cid:      "139477" }
    ],

    // formerEditors, add as many as you like
    // only "name" is required
    formerEditors:  [
      { name:       "Manu Sporny",
        url:        "http://manu.sporny.org/",
        w3cid:      "41758",
        company:    "Digital Bazaar",
        companyURL: "https://digitalbazaar.com/",
        note:       "CG Report" }
      ],

    // authors, add as many as you like.
    // This is optional, uncomment if you have authors as well as editors.
    // only "name" is required. Same format as editors.
    authors:  [
      { name:       "Dave Longley",
        url:        "https://digitalbazaar.com/author/dlongley/",
        w3cid:      "48025",
        company:    "Digital Bazaar",
        companyURL: "https://digitalbazaar.com/" }
    ],

    // name of the 
    group: "rch",
    testSuiteURI: "https://w3c.github.io/rdf-canon/tests/",
    xref: ["rdf11-concepts", "infra"],
    doJsonLd:     true,
    wgPublicList: "public-rch-wg",
    lint: { "informative-dfn": false }
  };
//]]>
</script>
<style>
  .hl-bold { font-weight: bold; color: #0a3; }
  .comment { color: #999; }
  table, thead, tr, td {
    padding: 5px;
    border-width: 1px;
    border-spacing: 0px;
    border-style: solid;
    border-collapse: collapse;
  }
  table.hash-related {
    caption-side: bottom;
    width: 100%;
  }
  table.hash-related > thead > tr> th {
    text-align: center;
  }
  .algorithm ol {
    counter-reset: numsection;
    list-style-type: none;
  }
  .algorithm ol>li {
    margin: 0.5em 0;
  }
  .algorithm ol>li:before {
    font-weight: bold;
    counter-increment: numsection;
    content: counters(numsection, ".") ") ";
  }
  a.externalDFN {border-bottom:  1px solid #99c; font-style: italic;}

  code { color: #c63501; }

  details {
    background-color: rgb(245,245,245);
    border-left: 0.3em solid rgb(200,200,200);
    padding: 0.3em;
  }
  summary {font-size: small; }
</style>
</head>

<body>
<section id="abstract">
  <p>RDF [[RDF11-CONCEPTS]] describes a graph-based data model for making claims
    about the world and provides the foundation for reasoning upon that graph
    of information. At times, it becomes necessary to compare the differences
    between sets of graphs, digitally sign them, or generate short identifiers
    for graphs via hashing algorithms. This document outlines an algorithm for
    normalizing <a>RDF datasets</a> such that these operations can be
    performed.</p>
</section>

<section id="sotd">
  <p>This document describes the <a>URDNA2015</a> algorithm for canonicalizing
    RDF datasets, which was the input from the
    <a href="https://www.w3.org/community/credentials/">W3C Credentials Community Group</a>
    published as [[CCG-RDC-FINAL]].
    There are other canonicalization algorithms actively being considered
    by the Working Group – notably [[Hogan-Canonical-RDF]];
    future versions of this document may change accordingly.
    See <span class="issue" data-number="6">Issue 6: Compare the two algorithms, and decide on basis for our work</span>
    and <span class="issue" data-number="10">Issue 10: C14N choice criteria</span>
    for further discussion.</p>
</section>

<section id="introduction">
  <h2>Introduction</h2>

  <p>When data scientists discuss canonicalization,
    they do so in the context of achieving a particular set of goals.
    Since the same information may sometimes be expressed in a variety of different ways,
    it often becomes necessary to transform each of these
    different ways into a single, standard representation.
    With a standard representation, the differences between
    two different sets of data can be easily determined,
    a cryptographically-strong hash identifier can be generated for a particular
    set of data,
    and a particular set of data may be digitally-signed for later
    verification.</p>

  <p>In particular, this specification is about normalizing
    <a>RDF datasets</a>, which are collections of graphs. Since
    a directed graph can express the same information in more than one
    way, it requires canonicalization to achieve the aforementioned goals
    and any others that may arise via serendipity.</p>

  <p>Most <a>RDF datasets</a> can be normalized fairly quickly, in terms
    of algorithmic time complexity. However, those that contain nodes that do
    not have globally unique identifiers pose a greater challenge. Normalizing
    these datasets presents the <dfn>graph isomorphism</dfn> problem, a
    problem that is believed to be difficult to solve quickly. More formally,
    it is believed to be an NP-Intermediate problem, that is, neither known to
    be solvable in polynomial time nor NP-complete. Fortunately, existing real
    world data is rarely modeled in a way that manifests this problem and new
    data can be modeled to avoid it. In fact, software systems can detect a
    problematic dataset and may choose to assume it's an attempted denial of
    service attack, rather than a real input, and abort.</p>

  <p>This document outlines an algorithm for generating a canonical
    serialization of an <a>RDF dataset</a> given an <a>RDF dataset</a> as input.
    The algorithm is called the
    <strong>Universal RDF Dataset Canonicalization Algorithm 2015</strong> or
    <a>URDNA2015</a>.</p>

  <section id="intro-uses">
    <h2>Uses of Dataset Canonicalization</h2>
    <p>There are different use cases where graph or dataset canonicalization are important:</p>
    <ul>
      <li>Determining if one serialization is isomorphic to another.</li>
      <li>Digital signing of graphs (datasets) independent of serialization or format.</li>
      <li>Comparing two graphs (datasets) to find differences.</li>
      <li>Communicating change sets when remotely updating an <a data-cite="RDF11-CONCEPTS#dfn-rdf-source">RDF source</a>.</li>
    </ul>
    <p>A canonicalization algorithm is necessary, but not necessarily sufficient, to handle many of these use cases. The use of <a>blank nodes</a> in RDF graphs and datasets has a long history and creates inevitable complexities. Blank nodes are used for different purposes:</p>
    <ul>
      <li>when a well known identifier for a node is not known, or the author of a document chooses not to unambiguously name that node,</li>
      <li>when a node is used to stitch together parts of a graph and the nodes themselves are not interesting (e.g., <a data-cite="RDF11-MT#rdf-collections">RDF Collections</a> in [[RDF11-MT]]),</li>
      <li>when someone is trying to create an intentionally difficult graph topology.</li>
    </ul>
    <p>Furthermore,
      RDF semantics dictate that deserializing an RDF document
      results in the creation of unique <a>blank nodes</a>,
      unless it can be determined that on each occasion,
      the <a>blank node</a> identifies the same resource.
      This is due to the fact that <a>blank node identifiers</a>
      are an aspect of a concrete RDF syntax
      and are not intended to be persistent or portable.
      Within the abstract RDF model,
      blank nodes do not have identifiers
      (although some
      RDF store
      implementations may use stable identifiers and may choose to make them portable).
      See <a data-cite="RDF11-CONCEPTS#section-blank-nodes">Blank Nodes</a>
      in [[!RDF11-CONCEPTS]] for more information.</p>

    <p>RDF does have a provision for allowing blank nodes
      to be published in an externally identifiable way through the use of
      <a data-cite="RDF11-CONCEPTS#dfn-skolem-iri">Skolem IRIs</a>,
      which allow a given RDF store to replace the use of blank nodes
      in a concrete syntax with <a>IRIs</a>,
      which then serve to repeatably identify that blank node within that particular RDF store;
      however, this is not generally useful for talking about the
      same graph in different RDF stores,
      or other concrete representations.
      In any case, a stable <a>blank node identifier</a> defined for one
      RDF store or serialization is arbitrary,
      and typically not relatable to the context within which it is used.</p>

    <p>This specification defines an algorithm for creating stable <a>blank node identifiers</a> repeatably for different serializations possibly using individualized <a>blank node identifiers</a> of the same RDF graph (dataset) by grounding each <a>blank node</a> through the nodes to which it is connected, essentially creating <em>Skolem <a>blank node identifiers</a></em>. As a result, a graph signature can be obtained by hashing a canonical serialization of the resulting <a>normalized dataset</a>, allowing for the isomorphism and digital signing use cases. As blank node identifiers can be stable even with other changes to a graph (dataset), in some cases it is possible to compute the difference between two graphs (datasets), for example if changes are made only to ground triples, or if new blank nodes are introduced which do not create an automorphic confusion with other existing blank nodes. If any information which would change the generated blank node identifier, a resulting diff might indicate a greater set of changes than actually exists.</p>

    <div class="ednote">
      <p>Add descriptions for relevant historical discussions and prior art:</p>
      <dl>
        <dt>[[DesignIssues-Diff]]</dt>
        <dd>TimBL's design note on problems with Diff.</dd>
        <dt>[[eswc2014Kasten]]</dt>
        <dd>A Framework for Iterative Signing of Graph Data on the Web.</dd>
        <dt>[[Hogan-Canonical-RDF]]</dt>
        <dd>Aiden Hogan's paper on canonicalizing RDF</dd>
        <dt>[[HPL-2003-142]]</dt>
        <dd>Jeremy J. Carroll's paper on signing RDF graphs.</dd>
      </dl>
    </div>
  </section>

  <section id="how-to-read">
    <h2>How to Read this Document</h2>

    <p>This document is a detailed specification for an <a>RDF dataset</a>
      canonicalization algorithm. The document is primarily intended for the
      following audiences:</p>

    <ul>
      <li>Software developers that want to implement an <a>RDF dataset</a>
        canonicalization algorithm.</li>
      <li>Masochists.</li>
    </ul>

    <p>To understand the basics in this specification you must be familiar with
      basic RDF concepts [[!RDF11-CONCEPTS]]. A working knowledge of
      <a href="https://en.wikipedia.org/wiki/Graph_theory">graph theory</a> and
      <a href="https://en.wikipedia.org/wiki/Graph_isomorphism">graph isomorphism</a>
      is also recommended.</p>
  </section>

  <section id="typo-conventions" class="informative">
    <h2>Typographical conventions</h2>
    <div data-include="common/typographical-conventions.html"></div>
  </section>
</section>

<section id="conformance"></section>

<section id="terminology" class="normative">
  <h2>Terminology</h2>

  <dl>
    <dt><dfn data-cite="INFRA#string">string</dfn></dt><dd>
      A string is a sequence of zero or more Unicode characters.</dd>
    <dt><code>true</code> and <code>false</code></dt><dd>
      Values that are used to express one of two possible boolean states.</dd>
    <dt><dfn data-cite="RDF11-CONCEPTS#dfn-iri" data-lt="internationalized resource identifier|iri|iris"><abbr title="Internationalized Resource Identifier">IRI</abbr></dfn></dt>
    <dd>An <a>IRI</a> (Internationalized Resource Identifier) is a string that conforms to the syntax
      defined in [[RFC3987]].</dd>
    <dt><dfn data-cite="RDF11-CONCEPTS#dfn-subject" data-lt="subject|subjects">subject</dfn></dt>
    <dd>A <a>subject</a>
      as specified by [[!RDF11-CONCEPTS]].</dd>
    <dt><dfn data-cite="RDF11-CONCEPTS#dfn-predicate" data-lt="predicate|predicates">predicate</dfn></dt>
    <dd>A <a>predicate</a>
      as specified by [[!RDF11-CONCEPTS]].</dd>
    <dt><dfn data-cite="RDF11-CONCEPTS#dfn-object" data-lt="object|objects">object</dfn></dt>
    <dd>An <a>object</a>
      as specified by [[!RDF11-CONCEPTS]].</dd>
    <dt><dfn data-cite="RDF11-CONCEPTS#dfn-rdf-triple" data-lt="rdf triple|rdf triples|triple|triples">RDF triple</dfn></dt>
    <dd>A <a>triple</a>
      as specified by [[!RDF11-CONCEPTS]].</dd>
    <dt><dfn data-cite="RDF11-CONCEPTS#dfn-rdf-graph" data-lt="rdf graph|rdf graphs|graph|graphs">RDF graph</dfn></dt>
    <dd>An <a>RDF graph</a>
      as specified by [[!RDF11-CONCEPTS]].</dd>
    <dt><dfn data-cite="RDF11-CONCEPTS#dfn-graph-name" data-lt="graph name|graph names">graph name</dfn></dt>
    <dd>A <a>graph name</a>
      as specified by [[!RDF11-CONCEPTS]].</dd>
    <dt><dfn data-cite="RDF11-CONCEPTS#dfn-default-graph">default graph</dfn></dt>
    <dd>The <a>default graph</a>
      as specified by [[!RDF11-CONCEPTS]].</dd>
    <dt><dfn data-lt="quad|quads" class="no-export">quad</dfn></dt> <!-- TODO: should be defined in N-Quads -->
    <dd>A tuple composed of <a>subject</a>, <a>predicate</a>, <a>object</a>, and <a>graph name</a>.
      This is a generalization of an <a>RDF triple</a> along with a <a>graph name</a>.</dd>
    <dt><dfn data-cite="RDF11-CONCEPTS#dfn-rdf-dataset" data-lt="rdf dataset|rdf datasets|dataset|datasets">RDF dataset</dfn></dt>
    <dd>A <a>dataset</a>
      as specified by [[!RDF11-CONCEPTS]].
      For the purposes of this specification, an <a>RDF dataset</a>
      is considered to be a set of <a>quads</a></dd>
    <dt><dfn data-cite="RDF11-CONCEPTS#dfn-blank-node">blank node</dfn></dt>
    <dd>A <a>blank node</a>
      as specified by [[!RDF11-CONCEPTS]]. In short, it is a node in a graph that is
      neither an <a>IRI</a>, nor a
      <a>literal</a>.</dd>
    <dt><dfn data-cite="RDF11-CONCEPTS#dfn-blank-node-identifier">blank node identifier</dfn></dt>
    <dd>A <a>blank node identifier</a>
      as specified by [[!RDF11-CONCEPTS]]. In short, it is a <a>string</a> that begins
      with <code>_:</code> that is used as an identifier for a
      <a>blank node</a>. <a>Blank node identifiers</a>
      are typically implementation-specific local identifiers; this document
      specifies an algorithm for deterministically specifying them.
      A blank node not given an explicit identifier is called an "unlabeled blank node."
      Additionally, blank nodes may be explicitly labeled with an identifier.</dd>
    <dd class="note">
      Concrete syntaxes, like [[Turtle]] or [[JSON-LD]], prepend the blank node identifiers with the <code>_:</code> string
      to differentiate them from other nodes in graph. This is also the case for [[N-Quads]]; this affects the 
      algorithm itself which is based on calculating a hash over the representations <a>quads</a> in this format.
    </dd>
  </dl>
</section>

<section id="canonicalization">
  <h2>Canonicalization</h2>

  <p>Canonicalization is the process of transforming an
    <a>input dataset</a> to a <a>normalized dataset</a>. That
    is, any two <a>input datasets</a> that contain the same
    information, regardless of their arrangement, will be transformed into
    identical <a>normalized dataset</a>. The problem requires directed
    graphs to be deterministically ordered into sets of nodes and edges. This
    is easy to do when all of the nodes have globally-unique identifiers, but
    can be difficult to do when some of the nodes do not. Any nodes without
    globally-unique identifiers must be issued deterministic identifiers.</p>

  <p class="ednote">Strictly speaking, the normalized dataset must be serialized to be stable, as within a dataset, blank node identifiers have no meaning. This specification defines a <a>normalized dataset</a> to include stable identifiers for blank nodes, but practical uses of this will always generate a canonical serialization of such a dataset.</p>

  <p>In time, there may be more than one canonicalization algorithm and,
    therefore, for identification purposes, this algorithm is named the
    "Universal RDF Dataset Canonicalization Algorithm 2015"
    (<abbr title="Universal RDF Dataset Canonicalization Algorithm 2015"><dfn class="export">URDNA2015</dfn></abbr>).</p>

  <p class="ednote">This statement is overly prescriptive and does not include normative language.
    This spec should describe the theoretical basis for graph canonicalization and describe
    behavior using normative statements. The explicit algorithms should follow as an informative appendix.</p>

  <section id="canon-overview" class="informative">
    <h3>Overview</h3>

    <p>To determine a canonical labeling, <a>URDNA2015</a> considers the
      information connected to each blank node.
      Nodes with unique first degree information can immediately be issued a canonical identifier
      via the <a href="#issue-identifier">Issue Identifier algorithm</a>.
      When a node has non-unique first degree information,
      it is necessary to determine all information that is transitively connected
      to it throughout the entire dataset.
      <a href="#hash-1d-quads" class="sectionRef"></a> defines a
      node’s first degree information via its first degree hash. </p>

    <p>Hashes are computed from the information of each blank node.
      These hashes encode the mentions incident to each blank node.
      The <a>hash</a> of a string <var>s</var>, is the lower-case,
      hexidecimal representation of the result of passing <var>s</var>
      through a cryptographic hash function.
      URDNA2015 uses the SHA-256 hash algorithm.</p>
  </section>

  <section id="canon-terms">
    <h2>Canonicalization Algorithm Terms</h2>
    <dl>
      <dt><dfn data-lt="input dataset|input datasets">input dataset</dfn></dt>
      <dd>The abstract <a>RDF dataset</a> that is provided as input to
        the algorithm.</dd>
      <dt><dfn>normalized dataset</dfn></dt>
      <dd>The immutable, abstract <a>RDF dataset</a> and set of normalized
        <a>blank node identifiers</a> that are produced as output by the algorithm. A <a>normalized dataset</a> is a restriction on an <a>RDF dataset</a> where all nodes are labeled, and <a>blank nodes</a> are labeled with <a>blank node identifiers</a> consistent with running this algorithm on a base <a>RDF dataset</a>. A concrete serialization of an <a>normalized dataset</a> MUST label all <a>blank nodes</a> using these stable <a>blank node identifiers</a>.</dd>
      <dt><dfn data-lt="canonical n-quads">canonical n-quads form</dfn></dt>
      <dd>
        The canonicalized representation of a quad is based on
        <a data-cite="N-Triples#canonical-ntriples">canonical N-Triples</a>
        defined in [[N-Triples]].
        A quad in <a>canonical n-quads form</a> represents a <a>graph name</a> in the same manner as a <a>subject</a>,
        if present, and each quad is terminated with a single new line character (`U+000A`).
        <div class="ednote">
          At present, there is no existing definition for a canonicalized [[N-Quads]] form.
          There is a definition for
          <a data-cite="N-Triples#canonical-ntriples">canonical N-Triples</a>
          in [[N-Triples]], which defines the form of a single triple,
          without the terminating <a data-cite="N-Triples#grammar-production-EOL">EOL</a>.
        </div>
      </dd>
      <dt><dfn>identifier issuer</dfn></dt>
      <dd>An identifier issuer is used to issue new <a>blank node identifier</a>. It
        maintains a
        <a href="#bn-issuer-state">blank node identifier issuer state</a>.</dd>
      <dt><dfn>hash</dfn></dt>
      <dd>The lowercase, hexadecimal representation of a message digest.</dd>
      <dt><dfn>hash algorithm</dfn></dt>
      <dd>The hash algorithm used by <a>URDNA2015</a>, namely, SHA-256.</dd>
      <dt><dfn data-cite="XPATH-FUNCTIONS#codepoint-collation" data-lt="code point order|code point ordered|unicode codepoint collation">Unicode code point order</dfn></dt>
      <dd>This refers to determining the order of two Unicode strings (`A` and `B`),
        using <a>Unicode Codepoint Collation</a>,
        as defined in [[XPATH-FUNCTIONS]],
        which defines a
        <a href="https://en.wikipedia.org/wiki/Total_order">total ordering</a>
        of <a>strings</a> comparing code points.
      </dd>
      <dt><dfn data-lt="mention">mention set</dfn></dt>
      <dd>The set of all <a>quads</a> in a <a>dataset</a>
        that mention a node <var>n</var> is called its <a>mention set</a> of <var>n</var>,
        denoted <var>Q<sub>n</sub></var>.</dd>
      <dt><dfn>gossip path</dfn></dt>
      <dd>The gossip path between two <a>blank nodes</a> contained within
        <a>quads</a> in a <a>dataset</a>, where the path is a sequence
        of nodes and quads such that the first quad includes
        the starting node as an component, and the last quad includes
        the ending node as an component with each quad in the path
        containing both the preceding and following nodes.</dd>
    </dl>
  </section>

  <section id="canon-state">
    <h2>Canonicalization State</h2>

    <p>When performing the steps required by the canonicalization algorithm,
      it is helpful to track state in a data structure called the
      <dfn>canonicalization state</dfn>. The information contained in the
      <a>canonicalization state</a> is described below.</p>

    <dl>
      <dt><dfn>blank node to quads map</dfn></dt>
      <dd>A <a>map</a> that relates a <a>blank node identifier</a> to
        the <a>quads</a> in which they appear in the
        <a>input dataset</a>.</dd>
      <dt><dfn>hash to blank nodes map</dfn></dt>
      <dd>A <a>map</a> that relates a <a>hash</a> to a
        <a>list</a> of
        <a>blank node identifiers</a>.</dd>
      <dt><dfn>canonical issuer</dfn></dt>
      <dd>An <a>identifier issuer</a>, initialized with the
        prefix <code>c14n</code>, for issuing canonical
        <a>blank node identifiers</a>.
        <div class="ednote">
          Mapping all <a>blank nodes</a> to use this
          identifier spec means that an <a>RDF dataset</a> composed of two
          different <a>RDF graphs</a> will use different
          identifiers than that for the graphs taken independently. This may
          happen anyway, due to <a
          href="https://en.wikipedia.org/wiki/Automorphism">automorphisms</a>,
          or overlapping statements, but an identifier based on the resulting
          <a>hash</a> along with an issue sequence number specific to that <a>hash</a> would
          stand a better chance of surviving such minor changes, and allow the
          resulting information to be useful for <a href="https://www.w3.org/2001/sw/wiki/How_to_diff_RDF">RDF Diff</a>.
        </div>
      </dd>
    </dl>
  </section>

  <section id="bn-issuer-state">
    <h2>Blank Node Identifier Issuer State</h2>

    <p>During the canonicalization algorithm, it is sometimes necessary to
      issue new identifiers to <a>blank nodes</a>. The
      <a href="#issue-identifier">Issue Identifier algorithm</a> uses an
      <a>identifier issuer</a> to accomplish this task. The information
      an <a>identifier issuer</a> needs to keep track of is described
      below.</p>

    <dl>
      <dt><dfn>identifier prefix</dfn></dt>
      <dd>The identifier prefix is a string that is used at the beginning of an
        <a>blank node identifier</a>. It should be initialized to a
        string that is specified by the canonicalization algorithm. When
        generating a new <a>blank node identifier</a>, the prefix
        is concatenated with a <a>identifier counter</a>. For example,
        <code>c14n</code> is a proper initial value for the
        <a>identifier prefix</a> that would produce
        <a>blank node identifiers</a> like <code>c14n1</code>.</dd>
      <dt><dfn>identifier counter</dfn></dt>
      <dd>A counter that is appended to the <a>identifier prefix</a> to
        create an <a>blank node identifier</a>. It is initialized to
        <code>0</code>.</dd>
      <dt><dfn>issued identifiers map</dfn></dt>
      <dd>An <a>ordered map</a> that relates existing identifiers to issued identifiers,
        to prevent issuance of more than one new identifier per existing identifier,
        and to allow <a>blank nodes</a> to
        be reassigned identifiers some time after issuance.</dd>
    </dl>
  </section>

  <section id="canon-algorithm" class="algorithm">
    <h2>Canonicalization Algorithm</h2>
      <p class="ednote">At the time of writing, there are several open issues that will determine important details of the canonicalization algorithm.</p>
      <div class="issue" data-number="4"></div>
      <div class="issue" data-number="6"></div>
      <div class="issue" data-number="7"></div>
      <div class="issue" data-number="8"></div>
      <div class="issue" data-number="10"></div>
      <div class="issue" data-number="11"></div>
      <div class="issue" data-number="16"></div>
      <div class="issue" data-number="38"></div>
      <div class="issue" data-number="41"></div>
      <div class="issue" data-number="46"></div>

    <p>The canonicalization algorithm converts an <a>input dataset</a>
      into a <a>normalized dataset</a>. This algorithm will assign
      deterministic identifiers to any <a>blank nodes</a> in the
      <a>input dataset</a>.</p>

    <section id="canon-algo-overview" class="informative">
      <h3>Overview</h3>

      <p><a>URDNA2015</a> canonically labels an <a>RDF dataset</a>.
        In URDNA2015, an RDF dataset <var>D</var>
        is represented as a set of <a>quads</a> of the form `&lt; s, p, o, g >`
        where the graph component `g` is empty if and only if the
        <a data-lt="RDF triple">triple</a> `&lt; s, p, o >` is in the <a>default graph</a>.
        This algorithm considers an RDF dataset to be a set of quads.
        Two RDF datasets are considered to be isomorphic (i.e., the same modulo blank nodes),
        if and only if they return the same canonically labeled list of quads
        via <a>URDNA2015</a>.</p>

      <p><a>URDNA2015</a> consists of several sub-algorithms.
        These sub-algorithms are introduced in the following sub-sections.
        First, we give a high level summary of URDNA2015.</p>

      <ol>
        <li id="ca-hl-1"><strong>Initialization</strong>.
          Initialize the state needed for the rest of the algorithm
          using <a href="#canon-state" class="sectionRef"></a>.</li>
        <li id="ca-hl-2"><strong>Compute first degree hashes</strong>.
          Compute the first degree hash for each blank node in the dataset using <a href="#hash-1d-quads" class="sectionRef"></a>.</li>
        <li id="ca-hl-3"><strong>Canonically label unique nodes</strong>.
          Assign canonical identifiers via <a href="#issue-identifier" class="sectionRef"></a>,
          in <a>Unicode code point order</a>, to each blank node whose first degree hash is unique.</li>
        <li id="ca-hl-4"><strong>Compute N-degree hashes for non-unique nodes</strong>.
          For each repeated first degree hash (proceeding in <a>Unicode code point order</a>),
          compute the N-degree hash via <a href="#hash-nd-quads" class="sectionRef"></a>
          of every unlabeled blank node that corresponds to the given repeated hash.</li>
        <li id="ca-hl-5"><strong>Canonically label remaining nodes</strong>.
          In <a>Unicode code point order</a> of the N-degree hashes,
          issue canonical identifiers to each corresponding blank node using
          <a href="#issue-identifier" class="sectionRef"></a>.
          If more than one node produces the same N-degree hash,
          the order in which these nodes receive a canonical identifier does not matter.</li>
        <li id="ca-hl-6"><strong>Finish</strong>. Return the normalized dataset.</li>
      </ol>
    </section>

    <section id="canon-algo-examples" class="informative">
      <h3>Examples</h3>

      <aside id="ex-ca-unique-hashes"
            class="example"
            title="Unique hashes">
        <p>This example illustrates the <a href="#canon-algo-algo">Canonicalization Algorithm</a>
          where all blank nodes have unique first-degree hashes.</p>

        <figure id="fig-ca-unique-hashes" style="text-align:center">
          <!-- Source for this file is at https://docs.google.com/drawings/d/1LQ6fp4a35lrEOKRMD20gcncUkoitX0eW8QI_U2mQnAs -->
          <object data="unique-hashes.svg" style="width: 75%" type="image/svg+xml" aria-describedby="fig-unique-hashes-alt">
            <p id="fig-ca-unique-hashes-alt">
              The image represents the graph described in
              <a href="#ex-ca-unique-hashes-input">
                the following code block
              </a>.</p>
          </object>
          <figcaption>An illustration of a graph resulting in unique hashes.<br/>
            Image available in
            <a href="unique-hashes.svg" title="SVG image of a unique hashes">
              <abbr title="Scalable Vector Graphics">SVG</abbr>
            </a>.</figcaption>
        </figure>

        <pre id="ex-ca-unique-hashes-input"
             data-transform="updateExample"
             title="Graph with blank nodes resulting in unique hashes">
          <!--
            :p :q _:e0 .
            :p :r _:e1 .
            _:e0 :s :u .
            _:e1 :t :u .
          -->
        </pre>

        <p><a href="#ca-2">Step 2</a> is called twice, with each blank node (`e0` and `e1`).
          to populate <a>blank node to quads map</a>:</p>

        <table id="ex-ca-unique-bn-quads-map"
               class="hash-related numbered">
          <caption>Blank node to quads map for unique hashes</caption>
          <thead><tr>
            <th><var>identifier</var></th>
            <th><var>Q</var></th>
          </tr></thead>
          <tbody>
            <tr>
              <td>`e0`</td>
              <td>`:p :q e0 .`<br/>`e0 :s :u .`</td>
            </tr>
            <tr>
              <td>`e1`</td>
              <td>`:p :r e1 .`<br/>`e1 :t :u .`</td>
            </tr>
          </tbody>
        </table>

        <p><a href="#ca-3">Step 3</a> generates the first-degree
          hash for each blank node, which is explored further
          in <a href="#ex-1d-unique-hashes"></a>:</p>

        <table id="ex-ca-unique-1d-hashes"
               class="hash-related numbered">
          <caption>Hash to blank nodes map for unique hashes</caption>
          <thead><tr>
            <th><var>hash</var></th>
            <th><var>label(s)</var></th>
          </tr></thead>
          <tbody>
            <tr>
              <td>`21d1dd5ba21f3dee9d76c0c00c260fa6f5d5d65315099e553026f4828d0dc77a`</td>
              <td>`e0`</td>
            </tr>
            <tr>
              <td>`6fa0b9bdb376852b5743ff39ca4cbf7ea14d34966b2828478fbf222e7c764473`</td>
              <td>`e1`</td>
            </tr>
          </tbody>
        </table>

        <p><a href="#ca-4">Step 4</a> creates canonical identifiers for each
          blank node which has a unique hash:</p>

        <table id="ex-ca-unique-1d-labels"
               class="hash-related numbered">
          <caption>Canonical labels for unique hashes</caption>
          <thead><tr>
            <th><var>label</var></th>
            <th><var>canonical identifier</var></th>
          </tr></thead>
          <tbody>
            <tr>
              <td>`e0`</td>
              <td>`c14n0`</td>
            </tr>
            <tr>
              <td>`e1`</td>
              <td>`c14n1`</td>
            </tr>
          </tbody>
        </table>

        <p><a href="#ca-5">Step 5</a> has no effect,
          as there are no remaining blank nodes without canonical identifiers.</p>

        <p><a href="#ca-6">Step 6</a> generates
          the normalized dataset by replacing blank node identifiers in the original
          input with their canonical identifiers:</p>

        <pre id="ex-ca-unique-normalized-dataset" data-transform="updateExample">
          <!--
            :p :q _:c14n0 .
            :p :r _:c14n1 .
            _:c14n0 :s :u .
            _:c14n1 :t :u .
          -->
        </pre>
      </aside>

      <aside id="ex-ca-shared-hashes"
            class="example"
            title="Shared hashes">
        <p>This example illustrates the <a href="#canon-algo-algo">Canonicalization Algorithm</a>
          where hashing the statements mentioning
          those blank nodes have overlapping results.</p>

        <figure id="fig-ca-shared-hashes" style="text-align:center">
          <!-- Source for this file is at https://docs.google.com/drawings/d/1HWpz8S-PNaWi02-utF62HAMd_0b-AF_tHNSRRUQILbU -->
          <object data="shared-hashes.svg" style="width: 75%" type="image/svg+xml" aria-describedby="fig-unique-hashes-alt">
            <p id="fig-ca-shared-hashes-alt">
              The image represents the graph described in
              <a href="#ex-ca-shared-hashes-input">
                the following code block
              </a>.</p>
          </object>
          <figcaption>An illustration of a graph resulting in shared hashes.<br/>
            Image available in
            <a href="shared-hashes.svg" title="SVG image of a shared hashes">
              <abbr title="Scalable Vector Graphics">SVG</abbr>
            </a>.</figcaption>
        </figure>

        <pre id="ex-ca-shared-hashes-input"
             data-transform="updateExample"
             title="Graph with blank nodes resulting in shared hashes">
          <!--
            :p :q _:e0 .
            :p :q _:e1 .
            _:e0 :p _:e2 .
            _:e1 :p _:e3 .
            _:e2 :r _:e3 .
          -->
        </pre>

        <p><a href="#ca-2">Step 2</a> is called four times, with each blank node
          (`e0`, `e1`, `e2`, and `e3`)
          to populate <a>blank node to quads map</a>:</p>

        <table id="ex-ca-shared-bn-quads-map"
               class="hash-related numbered">
          <caption>Blank node to quads map for shared hashes</caption>
          <thead><tr>
            <th><var>identifier</var></th>
            <th><var>Q</var></th>
          </tr></thead>
          <tbody>
            <tr>
              <td>`e0`</td>
              <td>`:p :q e0 .`<br/>`e0 :p e2 .`</td>
            </tr>
            <tr>
              <td>`e1`</td>
              <td>`:p :q e1 .`<br/>`e1 :p e3 .`</td>
            </tr>
            <tr>
              <td>`e2`</td>
              <td>`e0 :p e2 .`<br/>`e2 :r e3 .`</td>
            </tr>
            <tr>
              <td>`e3`</td>
              <td>`e1 :p e3 .`<br/>`e2 :r e3 .`</td>
            </tr>
          </tbody>
        </table>

        <p><a href="#ca-3">Step 3</a> generates the first-degree
          hash for each blank node, which is explored further
          in <a href="#ex-1d-shared-hashes"></a>
          (note that the hashes for `e0` and `e1` are shared):</p>

        <table id="ex-ca-shared-1d-hash-to-bn"
               class="hash-related numbered">
          <caption>Hash to blank nodes map shared hashes</caption>
          <thead><tr>
            <th><var>hash</var></th>
            <th><var>identifier(s)</var></th>
          </tr></thead>
          <tbody>
            <tr>
              <td>`3b26142829b8887d011d779079a243bd61ab53c3990d550320a17b59ade6ba36`</td>
              <td>`e0`, `e1`</td>
            </tr>
            <tr>
              <td>`15973d39de079913dac841ac4fa8c4781c0febfba5e83e5c6e250869587f8659`</td>
              <td>`e2`</td>
            </tr>
            <tr>
              <td>`7e790a99273eed1dc57e43205d37ce232252c85b26ca4a6ff74ff3b5aea7bccd`</td>
              <td>`e3`</td>
            </tr>
          </tbody>
        </table>

        <p><a href="#ca-4">Step 4</a> creates canonical identifiers for each
          blank node which has a unique hash:</p>

        <table id="ex-ca-shared-canon-ids"
               class="hash-related numbered">
          <caption>Canonical identifiers for shared hashes</caption>
          <thead><tr>
            <th><var>identifier</var></th>
            <th><var>canonical identifier</var></th>
          </tr></thead>
          <tbody>
            <tr>
              <td>`e2`</td>
              <td>`c14n0`</td>
            </tr>
            <tr>
              <td>`e3`</td>
              <td>`c14n1`</td>
            </tr>
          </tbody>
        </table>

        <p><a href="#ca-5">Step 5</a> is run on `e0` and `e1`, separately,
          which share the same hash,
          and use separate instances of a <var>temporary issuer</var>,
          (as explored in <a href="#ex-nd-shared-hashes"></a>)
          to create the <var>hash path list</var>
          composed of the hash result
          and temporary identifier mappings from
          <a href="#hash-nd-quads">Hash N-Degree Quads algorithm</a>
          for each of these blank nodes:</p>

        <table id="ex-ca-shared-result-e0"
               class="hash-related numbered">
          <caption>Result for `e0`</caption>
          <tbody>
            <tr>
              <td><var>temporary issuer</var> mappings</td>
              <td>
                <table class="hash-related">
                  <thead><tr>
                    <th><var>original</var></th>
                    <th><var>canonical</var></th>
                  </tr></thead>
                  <tbody>
                    <tr><td>`e0`</td><td>`b0`</td></tr>
                  </tbody>
                </table>
              </td>
            </tr>
            <tr>
              <td><var>hash</var></td>
              <td>`fbc300de5afafd97a4b9ee1e72b57754dcdcb7ebb724789ac6a94a5b82a48d30`</td>
            </tr>
          </tbody>
        </table>

        <table id="ex-ca-shared-result-e1"
               class="hash-related numbered">
          <caption>Result for `e1`</caption>
          <tbody>
            <tr>
              <td><var>temporary issuer</var> mappings</td>
              <td>
                <table class="hash-related">
                  <thead><tr>
                    <th><var>original</var></th>
                    <th><var>canonical</var></th>
                  </tr></thead>
                  <tbody>
                    <tr><td>`e1`</td><td>`b0`</td></tr>
                  </tbody>
                </table>
              </td>
            </tr>
            <tr>
              <td><var>hash</var></td>
              <td>`2c0b377baf86f6c18fed4b0df6741290066e73c932861749b172d1e5560f5045`</td>
            </tr>
          </tbody>
        </table>

        <p><a href="#ca-5-3">Step 5.3</a> creates
          the canonical identifiers for the temporary identifiers
          established in the previous step
          running in order of the <var>hash</var> component from each result.
          This updates the <a>canonical issuer</a> with the following
          mappings:</p>

        <table id="ex-ca-shared-canon-identifiers"
               class="hash-related numbered">
          <caption>Original to canonical blank node identifiers</caption>
          <thead><tr>
            <th><var>original</var></th>
            <th><var>canonical</var></th>
          </tr></thead>
          <tbody>
            <tr><td>`e0`</td><td>`c14n3`</td></tr>
            <tr><td>`e1`</td><td>`c14n2`</td></tr>
            <tr><td>`e2`</td><td>`c14n0`</td></tr>
            <tr><td>`e3`</td><td>`c14n1`</td></tr>
          </tbody>
        </table>

        <p><a href="#ca-6">Step 6</a> generates
          the normalized dataset by replacing blank node identifiers in the original
          input with their canonical identifiers:</p>

        <pre id="ex-ca-normalized-shared-dataset" data-transform="updateExample">
          <!--
            :p :q _:c14n2 .
            :p :q _:c14n3 .
            _:c14n0 :r _:c14n1 .
            _:c14n2 :p _:c14n1 .
            _:c14n3 :p _:c14n0 .
          -->
        </pre>
      </aside>
    </section>

    <section id="canon-algo-algo">
      <h3>Algorithm</h3>

      <ol>
        <li id="ca-1">Create the <a>canonicalization state</a>.
          <details>
            <summary>Explanation</summary>
            <p>This has the effect of initializing the
              <a>blank node to quads map</a>,
              and the <a>hash to blank nodes map</a>,
              as well as instantiating a new <a>canonical issuer</a>.</p>
          </details>
        </li>
        <li id="ca-2">For every <a>quad</a> <var>Q</var> in <a>input dataset</a>:
          <ol>
            <li id="ca-2-1">For each <a>blank node</a> that is a component of <var>Q</var>,
              add a reference to <var>Q</var> from the
              [= map/entry | map entry =] for the
              <a>blank node identifier</a> <var>identifier</var>
              in the <a>blank node to quads map</a>,
              creating a new entry if necessary.
              <details>
                <summary>Explanation</summary>
                <p>This establishes the <a>blank node to quads map</a>,
                  relating each <a>blank node</a> with the set of <a>quads</a>
                  of which it is a component.</p>
                <p class="note">
                  <a data-cite="RDF11-CONCEPTS#dfn-literal">Literal</a> components of
                  <a>quads</a> are not subject to any normalization.
                  As noted in
                  <a data-cite="RDF11-CONCEPTS#section-Graph-Literal">Section 3.3</a>
                  of [[RDF11-CONCEPTS]],
                  <a data-cite="RDF11-CONCEPTS#dfn-literal-term-equality">literal term equality</a>
                  is based on the
                  <a data-cite="RDF11-CONCEPTS#dfn-lexical-form">lexical form</a>,
                  rather than the <a data-cite="RDF11-CONCEPTS#dfn-literal-value">literal value</a>,
                  so two literals `"01"^^xs:integer` and `"1"^^xs:integer` are treated as distinct resources.
                </p>
              </details>
            </li>
          </ol>
        </li>
        <li id="ca-3">For each [= map/key =] <var>n</var>
          in the <a>blank node to quads map</a>:
          <details>
            <summary>Explanation</summary>
            <p>This step creates a hash for every blank node in the input document.
              Some blank nodes will lead to a unique hash,
              while other blank nodes may share a common hash.</p>
          </details>
          <ol>
            <li id="ca-3-1">Create a <a>hash</a>, <var>h<sub>f</sub>(n)</var>,
              for <var>n</var> according to the
              <a href="#hash-1d-quads">Hash First Degree Quads algorithm</a>.</li>
            <li id="ca-3-2">Add <var>h<sub>f</sub>(n)</var> and <var>n</var> to
              <a>hash to blank nodes map</a>, including repetitions,
              creating a new entry if necessary.</li>
          </ol>
        </li>
        <li id="ca-4">For each <var>hash</var> to <var>identifier list</var>
          [= map/entry | map entry =] in
          <a>hash to blank nodes map</a>, <a>code point ordered</a> by <var>hash</var>:
          <details>
            <summary>Explanation</summary>
            <p>This step establishes the canonical identifier for blank nodes having
              a unique hash, which are recorded in the <a>canonical issuer</a>.</p>
          </details>
          <ol>
            <li id="ca-4-1">If <var>identifier list</var> has more than one entry,
              continue to the next mapping.</li>
            <li id="ca-4-2">Use the
              <a href="#issue-identifier">Issue Identifier algorithm</a>,
              passing <a>canonical issuer</a> and the
              single <a>blank node identifier</a>, <var>identifier</var> in
              <var>identifier list</var> to issue a
              canonical replacement identifier for <var>identifier</var>.</li>
            <li id="ca-4-3">Remove the [= map/entry | map entry =] for <var>hash</var> from the
              <a>hash to blank nodes map</a>.</li>
          </ol>
        </li>
        <li id="ca-5">For each <var>hash</var> to <var>identifier list</var>
          [= map/entry | map entry =] in
          <a>hash to blank nodes map</a>, <a>code point ordered</a> by
          <var>hash</var>:
          <details>
            <summary>Explanation</summary>
            <p>This step establishes the canonical identifier for blank nodes having
              a shared hash.
              This is done by creating unique blank node identifiers for all
              blank nodes traversed by the <a href="#hash-nd-quads">Hash N-Degree Quads algorithm</a>,
              running through each blank node without a canonical identifier in the order
              of the hashes established in the previous step.</p>
          </details>
          <ol>
            <li id="ca-5-1">Create <var>hash path list</var> where each item will be a result
              of running the
              <a href="#hash-nd-quads">Hash N-Degree Quads algorithm</a>.
              <details>
                <summary>Explanation</summary>
                <p>This list establishes an order for those blank nodes
                  sharing a common first-degree hash.</p>
              </details>
            </li>
            <li id="ca-5-2">For each <a>blank node identifier</a>
              <var>n</var> in <var>identifier list</var>:
              <ol>
                <li id="ca-5-2-1">If a canonical identifier has already been issued for
                  <var>n</var>, continue to the next
                  <a>blank node identifier</a>.</li>
                <li id="ca-5-2-2">Create <var>temporary issuer</var>, an
                  <a>identifier issuer</a> initialized with the prefix
                  <code>b</code>.</li>
                <li id="ca-5-2-3">Use the
                  <a href="#issue-identifier">Issue Identifier algorithm</a>,
                  passing <var>temporary issuer</var> and <var>n</var>, to
                  issue a new temporary <a>blank node identifier</a> <var>b<sub>n</sub></var>
                  to <var>n</var>.</li>
                <li id="ca-5-2-4">Run the
                  <a href="#hash-nd-quads">Hash N-Degree Quads algorithm</a>,
                  passing the <a>canonicalization state</a>,
                  <var>n</var> for <var>identifier</var>, and
                  <var>temporary issuer</var>,
                  appending the
                  result to the <var>hash path list</var>.</li>
              </ol>
            </li>
            <li id="ca-5-3">For each <var>result</var> in the <var>hash path list</var>,
              <a>code point ordered</a> by the <var>hash</var> in <var>result</var>:
              <details>
                <summary>Explanation</summary>
                <p>The previous step created temporary identifiers for the
                  blank nodes sharing a common first degree hash,
                  which is now used to generate their canonical identifiers.</p>
              </details>
              <ol>
                <li id="ca-5-3-1">For each <a>blank node identifier</a>,
                  <var>existing identifier</var>, that was issued a temporary
                  identifier by <var>identifier issuer</var> in <var>result</var>,
                  issue a canonical identifier,
                  in the same order,
                  using the <a href="#issue-identifier">Issue Identifier algorithm</a>,
                  passing <a>canonical issuer</a> and <var>existing identifier</var>.
                  <details>
                    <summary>Explanation</summary>
                    <p>In <a href="#ca-5-2">Step 5.2</a>,
                      <var>hash path list</var> was created with an ordered
                      set of results.
                      Each result contained a <var>temporary issuer</var>
                      which recorded temporary identifiers associated with
                      a particular <a>blank node identifier</a> in
                      <var>identifier list</var>.
                      This step processes each returned <var>temporary issuer</var>,
                      in order, and allocates canonical identifiers
                      to the temporary identifier mappings contained
                      within each <var>temporary issuer</var>,
                      creating a full order on the remaining blank nodes
                      with unissued canonical identifiers.
                    </p>
                  </details>
                </li>
              </ol>
            </li>
          </ol>
        </li>
        <li id="ca-6">For each <a>quad</a>, <var>q</var>, in <a>input dataset</a>:
          <details>
            <summary>Explanation</summary>
            <p>This step populates the <a>normalized dataset</a> with quads
              substituting the original blank node identiers,
              with the newly established canonical blank node identifiers.</p>
          </details>
          <ol>
            <li id="ca-6-1">Create a copy, <var>quad copy</var>, of <var>q</var> and replace any
              existing <a>blank node identifier</a> <var>n</var> using the
              canonical identifiers previously issued
              by <a>canonical issuer</a>.</li>
            <li id="ca-6-2">Add <var>quad copy</var> to the
              <a>normalized dataset</a>.</li>
          </ol>
        </li>
        <li id="ca-7">Return the <a>normalized dataset</a>.</li>
      </ol>
    </section>
  </section>

  <section id="issue-identifier" class="algorithm">
    <h2>Issue Identifier Algorithm</h2>

    <p>This algorithm issues a new <a>blank node identifier</a> for
      a given existing <a>blank node identifier</a>. It also updates
      state information that tracks the order in which new
      <a>blank node identifiers</a> were issued. The order of issuance is
      important for canonically labeling blank nodes that are isomorphic
      to others in the dataset.</p>

    <section id="issue-identifier-overview">
      <h3>Overview</h3>

      <p>The algorithm maintains an <a>issued identifiers map</a> to
        relate an existing <a>blank node identifier</a> from the <a>input dataset</a>
        to a new <a>blank node identifier</a> using a given <a>identifier prefix</a>
        (`c14n`) with new identifiers issued by appending an incrementing number.
        For example, when called for a blank node identifier such as `e3`,
        it might result in a issued identifier of `c14n1`.</p>
    </section>

    <section id="issue-identifier-algorithm">
      <h3>Algorithm</h3>

      <p>The algorithm takes an <a>identifier issuer</a> <var>I</var> and an
        <var>existing identifier</var> as inputs. The output is a new
        <var>issued identifier</var>. The steps of the algorithm are:</p>

      <ol>
        <li id="iia-1">If there is a
          [= map/entry | map entry =] for <var>existing identifier</var> in
          <a>issued identifiers map</a> of <var>I</var>,
          return it.</li>
        <li id="iia-2">Generate <var>issued identifier</var> by concatenating
          <a>identifier prefix</a> with the string value of
          <a>identifier counter</a>.</li>
        <li id="iia-3">Add an [= map/entry =]
          mapping <var>existing identifier</var> to <var>issued identifier</var>
          to the <a>issued identifiers map</a> of <var>I</var>.</li>
        <li id="iia-4">Increment <a>identifier counter</a>.</li>
        <li id="iia-5">Return <var>issued identifier</var>.</li>
      </ol>
    </section>
  </section>

  <section id="hash-1d-quads" class="algorithm">
    <h2>Hash First Degree Quads</h2>

    <p>This algorithm calculates a <a>hash</a> for a given <a>blank node</a>
      across the <a>quads</a> in a <a>dataset</a> in which that blank node
      is a component.
      If the hash uniquely identifies that blank node,
      no further examination is necessary.
      Otherwise, a hash will be created for the blank node using
      the algorithm in <a href="#hash-nd-quads" class="sectionRef"></a>
      invoked via <a href="#canon-algorithm" class="sectionRef"></a>.</p>

    <section id="hash-1d-quads-overview" class="informative">
      <h3>Overview</h3>

      <p>To determine whether the first degree information of a node <var>n</var> is unique,
        a <a>hash</a> is assigned to its <a>mention set</a>,
        <var>Q<sub>n</sub></var>.
        The first degree hash of a blank node <var>n</var>,
        denoted <var>h<sub>f</sub>(n)</var>,
        is the hash that results from <a href="#hash-1d-quads" class="sectionRef"></a>
        when passing <var>n</var>.
        Nodes with unique first degree hashes have unique first degree information.</p>

      <p>For consistency, <a>blank node identifiers</a> used in <var>Q<sub>n</sub></var>
        are replaced with placeholders in a <a>canonical n-quads</a> serialization of that quad.
        Every blank node component is replaced with either `a` or `z`,
        depending on if that component is <var>n</var> or not.</p>

      <p>The resulting serialized quads are then <a>code point ordered</a>,
        concatenated, and hashed.
        This hash is the first degree hash of <var>n</var>, <var>h<sub>f</sub>(n)</var>.</p>
    </section>

    <section id="hash-1d-quads-examples" class="informative">
      <h3>Examples</h3>

      <aside id="ex-1d-unique-hashes"
            class="example"
            title="Unique hashes">
        <p>This example illustrates hashing quads containing
          blank nodes where hashing the statements mentioning
          those blank nodes generates unique results.</p>

        <figure id="fig-unique-hashes" style="text-align:center">
          <!-- Source for this file is at https://docs.google.com/drawings/d/1LQ6fp4a35lrEOKRMD20gcncUkoitX0eW8QI_U2mQnAs -->
          <object data="unique-hashes.svg" style="width: 75%" type="image/svg+xml" aria-describedby="fig-unique-hashes-alt">
            <p id="fig-unique-hashes-alt">
              The image represents the graph described in
              <a href="#ex-1d-unique-hashes-input">
                the following code block
              </a>.</p>
          </object>
          <figcaption>An illustration of a graph resulting in unique hashes.<br/>
            Image available in
            <a href="unique-hashes.svg" title="SVG image of a unique hashes">
              <abbr title="Scalable Vector Graphics">SVG</abbr>
            </a>.</figcaption>
        </figure>

        <pre id="ex-1d-unique-hashes-input"
             data-transform="updateExample"
             title="Graph with blank nodes resulting in unique hashes">
          <!--
            :p :q _:e0 .
            :p :r _:e1 .
            _:e0 :s :u .
            _:e1 :t :u .
          -->
        </pre>

        <p>The algorithm will be called twice, with each blank node (`e0` and `e1`).
          Running the algorithm with the reference node `e0` results in the
          following quads, after replacing blank nodes:</p>

        <pre id="ex-1d-unique-hashes-e0-quads" data-transform="updateExample">
          <!--
            :p :q _:a .
            _:a :s :u .
          -->
        </pre>

        <p>These are then serialized to <a>canonical n-quads form</a>:
          <code id="ex-1d-unique-hashes-e0-quads-c14n"
            data-result-for="ex-1d-unique-hashes-e0-quads"
            data-xform="to-c14n-quads"
          >'&lt;http://example.com/#p&gt; &lt;http://example.com/#q&gt; _:a .\n_:a &lt;http://example.com/#s&gt; &lt;http://example.com/#u&gt; .\n'</code>,
          concatenated and hashed
          using the <a>hash algorithm</a> (SHA-256) resulting in
          <code id="ex-1d-unique-hashes-e0-quads-hash"
            data-result-for="ex-1d-unique-hashes-e0-quads"
            data-xform="to-sha256"
          >21d1dd5ba21f3dee9d76c0c00c260fa6f5d5d65315099e553026f4828d0dc77a</code>.
        </p>

        <p>The algorithm is run a second time with the reference node `e1` resulting
          in the following quads:</p>

        <pre id="ex-1d-unique-hashes-e1-quads" data-transform="updateExample">
          <!--
            :p :r _:a .
            _:a :t :u .
          -->
        </pre>

        <p>These are then serialized to <a>canonical n-quads form</a>:
          <code id="ex-1d-unique-hashes-e1-quads-c14n"
            data-result-for="ex-1d-unique-hashes-e1-quads"
            data-xform="to-c14n-quads"
          >'&lt;http://example.com/#p&gt; &lt;http://example.com/#r&gt; _:a .\n_:a &lt;http://example.com/#t&gt; &lt;http://example.com/#u&gt; .\n'</code>,
          concatenated and hashed as before resulting in
          <code id="ex-1d-unique-hashes-e1-quads-hash"
            data-result-for="ex-1d-unique-hashes-e1-quads"
            data-xform="to-sha256"
          >6fa0b9bdb376852b5743ff39ca4cbf7ea14d34966b2828478fbf222e7c764473</code>.
        </p>

        <p>Thus the generated hashes each reference just a single blank node,
          allowing the canonicalization algorithm to use only the
          Hash First Degree Quads algorithm.</p>
      </aside>

      <aside id="ex-1d-shared-hashes"
            class="example"
            title="Shared hashes">
        <p>This example illustrates hashing quads containing
          blank nodes where hashing the statements mentioning
          those blank nodes have overlapping results.</p>

        <figure id="fig-shared-hashes" style="text-align:center">
          <!-- Source for this file is at https://docs.google.com/drawings/d/1HWpz8S-PNaWi02-utF62HAMd_0b-AF_tHNSRRUQILbU -->
          <object data="shared-hashes.svg" style="width: 75%" type="image/svg+xml" aria-describedby="fig-shared-hashes-alt">
            <p id="fig-shared-hashes-alt">
              The image represents the graph described in
              <a href="#ex-1d-shared-hashes-input">
                the following code block
              </a>.</p>
          </object>
          <figcaption>An illustration of a graph resulting in shared hashes.<br/>
            Image available in
            <a href="shared-hashes.svg" title="SVG image of a graph resulting in shared hashes">
              <abbr title="Scalable Vector Graphics">SVG</abbr>
            </a>.</figcaption>
        </figure>
          
        <pre id="ex-1d-shared-hashes-input"
             data-transform="updateExample"
             title="Graph with blank nodes resulting in shared hashes">
          <!--
            :p :q _:e0 .
            :p :q _:e1 .
            _:e0 :p _:e2 .
            _:e1 :p _:e3 .
            _:e2 :r _:e3 .
          -->
        </pre>

        <p>The algorithm will be called four times, with each blank node
          (`e0`, `e1`, `e2`, and `e3`).
          Running the algorithm with the reference node `e0` results in the
          following quads, after replacing blank nodes:</p>

        <pre id="ex-1d-shared-hashes-e0-quads" data-transform="updateExample">
          <!--
            :p :q _:a .
            _:a :p _:z .
          -->
        </pre>

        <p>Which hashes to:
          <code id="ex-1d-shared-hashes-e0-quads-hash"
            data-result-for="ex-1d-shared-hashes-e0-quads"
            data-xform="to-sha256"
          >3b26142829b8887d011d779079a243bd61ab53c3990d550320a17b59ade6ba36</code>.
        </p>

        <p>Note that using reference node `e1` results in the same quads,
          and thus results in the same hash.</p>

        <p>Using the reference node `e2` results in the following quads:</p>

        <pre id="ex-1d-shared-hashes-e2-quads" data-transform="updateExample">
          <!--
            _:z :p _:a .
            _:a :r _:z .
          -->
        </pre>

        <p>Which hashes to:
          <code id="ex-1d-shared-hashes-e2-quads-hash"
            data-result-for="ex-1d-shared-hashes-e2-quads"
            data-xform="to-sha256"
          >15973d39de079913dac841ac4fa8c4781c0febfba5e83e5c6e250869587f8659</code>.
        </p>

        <p>Lastly, using the reference node `e3` results in the following quads:</p>

        <pre id="ex-1d-shared-hashes-e3-quads" data-transform="updateExample">
          <!--
            _:z :p _:a .
            _:z :r _:a .
          -->
        </pre>

        <p>Which hashes to:
          <code id="ex-1d-shared-hashes-e3-quads-hash"
            data-result-for="ex-1d-shared-hashes-e3-quads"
            data-xform="to-sha256"
          >7e790a99273eed1dc57e43205d37ce232252c85b26ca4a6ff74ff3b5aea7bccd</code>.
        </p>

        <p>The hashes for `e2` and `e3` are unique, but `e0`,
          and `e1` share a common hash,
          which will require the use of the
          <a href="#hash-nd-quads-algorithm">Hash N-Degree Quads Algorithm</a>,
          as it is necessary to consider quads further removed from the direct mentions
          to determine a unique hash.</p>
      </aside>
    </section>

    <section id="hash-1d-quads-algorithm">
      <h3>Algorithm</h3>

      <p>This algorithm takes the <a>canonicalization state</a> and a
        <dfn>reference blank node identifier</dfn> as inputs.</p>

      <ol>
        <li id="h1d-1">Initialize <dfn>nquads</dfn> to an empty <a>list</a>.
          It will be used to store quads in <a>canonical n-quads form</a>.</li>
        <li id="h1d-2">Get the <a>list</a> of <a>quads</a> <var>quads</var>
          from the [= map/entry | map entry =] for
          <a>reference blank node identifier</a> in the
          <a>blank node to quads map</a>.</li>
        <li id="h1d-3">For each <a>quad</a> <var>quad</var> in <var>quads</var>:
          <ol>
            <li id="h1d-3-1">Serialize the <a>quad</a> in <a>canonical n-quads form</a> with the
              following special rule:
              <ol>
                <li id="h1d-3-1-1">If any component in <var>quad</var> is an
                  <a>blank node</a>, then serialize it using a
                  special identifier as follows:
                  <ol>
                    <li id="h1d-3-1-1-1">If the <a>blank node</a>'s existing
                    <a>blank node identifier</a> matches the
                    <a>reference blank node identifier</a> then use the
                    <a>blank node identifier</a> <code>a</code>,
                    otherwise, use the <a>blank node identifier</a>
                    <code>z</code>.</li>
                  </ol>
                </li>
              </ol>
            </li>
          </ol>
        </li>
        <li id="h1d-4">Sort <a>nquads</a> in <a>Unicode code point order</a>.</li>
        <li id="h1d-5">Return the <a>hash</a> that results from passing the sorted
          and concatenated <a>nquads</a> through the
          <a>hash algorithm</a>.</li>
      </ol>
    </section>
  </section>

  <section id="hash-related-blank-node" class="algorithm">
    <h2>Hash Related Blank Node</h2>

    <p>This algorithm generates a <a>hash</a> for some
      <a>blank node</a> component of a <a>quad</a>,
      considering its position within that quad.
      This is used as part of the
      <a href="#hash-nd-quads-algorithm">Hash N-Degree Quads algorithm</a>
      to characterize the blank nodes related to some particular blank node
      within their <a>mention sets</a>.
    </p>

    <section id="hash-related-bn-overview" class="informative">
      <h3>Overview</h3>

      <p>An <em>identifier</em> for a <a>blank node</a>, <var>related</var>,
        which is a component of some <a>quad</a>, is used along
        with information describing its position within the quad to create
        a representation of that blank node within the quad,
        which is then hashed.
        The identifier is first found from the following:
      </p>
      <ol>
        <li>An issued identifier from <a>canonical issuer</a> in the <a>canonicalization state</a>,</li>
        <li>An issued identifier from <var>issuer</var>, or</li>
        <li>the result of the
          <a href="#hash-nd-quads-algorithm">Hash N-Degree Quads algorithm</a>
          for <var>related</var>.</li>
      </ol>
    </section>

    <section id="hash-related-bn-examples" class="informative">
      <h3>Examples</h3>

      <aside id="hash-related-ex1"
            class="example"
            title="With assigned canonical identifier">
        <p>This example illustrates generating the related hash
          for a blank node component of a quad, where the component
          is in the <a>object</a> position and has already had
          an assigned canonical identifier from the <a>canonical issuer</a>.</p>

        <p>Given the predicate `:p`,
          <var>related</var> <a>blank node identifier</a> `e2`
          (already assigned the canonical <a>blank node identifier</a> `c14n0`),
          an <var>input</var>
          is created as `o&lt;http://example.com/#p&gt;c14n0`,
          which hashes to `29cf7e22790bc2ed395b81b3933e5329fc7b25390486085cac31ce7252ca60fa`.</p>

        <p>If such an identifier had not yet been established,
          it would instead use the results of the
          <a href="#hash-1d-quads">Hash First Degree Quads algorithm</a>.</p>
      </aside>
    </section>

    <section id="hash-related-algorithm">
      <h3>Algorithm</h3>

      <p>This algorithm creates a <a>hash</a> to identify how one
        <a>blank node</a> is related to another. It takes the
        <a>canonicalization state</a>, a <var>related</var>
        <a>blank node identifier</a>, a <var>quad</var>, an
        <a>identifier issuer</a>, <var>issuer</var>, and a
        <a>string</a> <var>position</var> as inputs.</p>

      <ol>
        <li id="hrbn-1">Set the <var>identifier</var> to use for <var>related</var>, preferring
          first the canonical identifier for <var>related</var> if issued, second
          the identifier issued by <var>issuer</var> if issued, and last, if
          necessary, the result of the
          <a href="#hash-1d-quads">Hash First Degree Quads algorithm</a>,
          passing <var>related</var>.
          <details>
            <summary>Explanation</summary>
            <p>If a canonical identifier was already issued for <var>related</var>,
              it will be in the <a>canonical issuer</a> contained within
              <a>canonicalization state</a>.
              Otherwise, the temporary <var>issuer</var> instance may already
              have a mapping for <var>related</var>.
              Lastly, if no identifier, canonical or temporary, has already been issued,
              a new identifier is created using the
              <a href="#hash-1d-quads">Hash First Degree Quads algorithm</a>.</p>
          </details>
        </li>
        <li id="hrbn-2">Initialize a <a>string</a> <var>input</var> to the value of
          <var>position</var>.</li>
        <li id="hrbn-3">If <var>position</var> is not <code>g</code>, append
          <code>&lt;</code>, the value of the <a>predicate</a> in
          <var>quad</var>, and <code>&gt;</code> to <var>input</var>.</li>
        <li id="hrbn-4">Append <var>identifier</var> to <var>input</var>.</li>
        <li id="hrbn-5">Return the <a>hash</a> that results from passing <var>input</var>
          through the <a>hash algorithm</a>.</li>
      </ol>
    </section>
  </section>

  <section id="hash-nd-quads" class="algorithm">
    <h2>Hash N-Degree Quads</h2>

    <p>This algorithm calculates a <a>hash</a> for a given <a>blank node</a>
      across the <a>quads</a> in a <a>dataset</a> in which that blank node
      is a component for which the hash does not uniquely identify that blank node.
      This is done by expanding the search from quads directly referencing that
      blank node (the <a>mention set</a>), to those quads
      which contain nodes which are also components of quads in the mention set,
      called the <a>gossip path</a>.
      This process proceeds in every greater degrees of indirection until
      a unique hash is obtained.</p>

    <p class="ednote">The 'path' terminology could also be changed to better
      indicate what a path is (a particular deterministic serialization for
      a subgraph/subdataset of nodes without globally-unique identifiers).</p>

    <section id="hash-nd-quads-overview" class="informative">
      <h3>Overview</h3>

      <p>Usually, when trying to determine if two nodes in a graph are
        equivalent, you simply compare their identifiers. However, what if the
        nodes don't have identifiers? Then you must determine if the two nodes
        have equivalent connections to equivalent nodes all throughout the
        whole graph. This is called the <a>graph isomorphism</a> problem. This
        algorithm approaches this problem by considering how one might draw
        a graph on paper. You can test to see if two nodes are equivalent
        by drawing the graph twice. The first time you draw the graph the
        first node is drawn in the center of the page. If you can draw the
        graph a second time such that it looks just like the first, except
        the second node is in the center of the page, then the nodes are
        equivalent. This algorithm essentially defines a deterministic way to
        draw a graph where, if you begin with a particular node, the graph
        will always be drawn the same way. If two graphs are drawn the same way
        with two different nodes, then the nodes are equivalent. A
        <a>hash</a> is used to indicate a particular way that the graph
        has been drawn and can be used to compare nodes.</p>

      <p>When two blank nodes have the same first degree hash,
        extra steps must be taken to detect global,
        or <em>N</em>-degree, distinctions.
        All information that is in any way connected to the blank node <var>n</var>
        through other blank nodes, even transitively, must be considered.</p>

      <p>To consider all transitive information,
        the algorithm traverses and encodes all possible paths of incident
        mentions emanating from <var>n</var>, called <a>gossip paths</a>,
        that reach every unlabeled blank node connected to <var>n</var>.
        Each unlabeled blank node is assigned a temporary identifier
        in the order in which it is reached in the
        gossip path being explored.
        The mentions that are traversed to reach
        connected blank nodes are encoded in these paths via related hashes.
        This provides a deterministic way to order all paths coming from <var>n</var> that
        reach all blank nodes connected to n without relying on input blank
        node identifiers.</p>
  
      <p>This algorithm works in concert with the main canonicalization algorithm
        to produce a unique, deterministic identifier for a particular blank
        node. This <a>hash</a> incorporates all of the information that
        is connected to the blank node as well as how it is connected. It does
        this by creating deterministic paths that emanate out from the blank
        node through any other adjacent blank nodes.</p>

      <p>Ultimately, the algorithm selects a shortest <a>gossip path</a>,
        distributing canonical identifiers to the unlabeled blank nodes
        in the order in which they appear in this path.
        The hash of this encoded shortest path,
        called the N-degree hash of <var>n</var>,
        distinguishes <var>n</var> from other blank nodes in the dataset.</p>

      <p>For clarity, we consider a <a>gossip path</a> encoded via the string <var>s</var>
        to be shortest provided that:</p>

      <ol>
        <li>The length of <var>s</var> is less than or equal to the length
          of any other gossip path string <var>s′</var>.</li>
        <li>If <var>s</var> and <var>s′</var> have the same length (as strings),
          then <var>s</var> is <a>code point ordered</a> less than or equal to <var>s′</var>.</li>
      </ol>

      <p>For example, <em>abc</em> is shorter than <em>bbc</em>,
        whereas <em>abcd</em> is longer than <em>bcd</em>.</p>

      <p>The following provides a high level outline for how the N-degree hash of <var>n</var>
        is computed along the shortest <a>gossip path</a>.
        Note that the full algorithm considers all gossip paths,
        ultimately returning the <a>hash</a> of the shortest encoded path.</p>

      <ol>
        <li id="ndh-hl-s1"><strong>Compute related hashes</strong>.
          Compute the related hash <var>H<sub>n</sub></var> set for <var>n</var>,
          i.e., all first degree <a>mentions</a> between <var>n</var> and another blank node.
          Note that this includes both labeled and unlabeled blank nodes.</li>
        <li id="ndh-hl-s2"><strong>Explore mentions</strong>.
          Given the related hash <var>x</var> in <var>H<sub>n</sub></var>,
          record <var>x</var> in the data to hash <var>D<sub>n</sub></var>.
          Determine whether each blank node reachable via the <a>mention</a> with related hash <var>x</var>
          has already received an identifier.
          <ol>
            <li id="ndh-hl-s2-1"><strong>Record the identifiers of labeled nodes</strong>.
              If a blank node already has an identifier,
              record its identifier in <var>D<sub>n</sub></var> once for every
              <a>mention</a> with related hash <var>x</var>.
              Skip to the next related hash in <var>H<sub>n</sub></var>
              and repeat <a href="#ndh-hl-s2">step 2</a>.</li>
            <li id="ndh-hl-s2-2"><strong>Distribute and record temporary identifiers to unlabeled nodes</strong>.
              For each unlabeled blank node,
              assign it a temporary identifier according to the order in which it is reached in the gossip path,
              recording its given identifier in <var>D<sub>n</sub></var> (including repetitions).
              Add each unlabeled node to the recursion list <var>R<sub>n</sub>(x)</var>
              in this same order (omitting repetitions).</li>
            <li id="ndh-hl-s2-3"><strong>Recurse on newly labeled nodes</strong>.
              For each <var>n<sub>i</sub></var> in <var>R<sub>n</sub>(x)</var>
              <ol>
                <li id="ndh-hl-s2-3-1">Record its identifier in <var>D<sub>n</sub></var></li>
                <li id="ndh-hl-s2-3-2">Append &lt; <var>r(i)</var> > to <var>D<sub>n</sub></var>
                  where <var>r(i)</var> is the data to hash that results from returning to
                  <a href="#ndh-hl-s1">step 1</a>,
                  replacing <var>n</var> with <var>n<sub>i</sub></var>.</li>
              </ol>
            </li>
          </ol>
        </li>
        <li id="ndh-hl-s3"><strong>Compute the <em>N</em>-degree hash of n</strong>.
          Hash <var>D<sub>n</sub></var> to return the <em>N</em>-degree hash of <var>n</var>,
          namely <var>h<sub>N</sub>(n)</var>.
          Return the updated issuer <var>I<sub>n</sub></var>
          that has now distributed temporary identifiers to all unlabeled blank nodes connected to <var>n</var>.</li>
      </ol>

      <p>As described above in <a href="#ndh-hl-s2-3">step 2.3</a>,
        <var>HN</var> recurses on each unlabeled blank node
        when it is first reached along the <a>gossip path</a> being explored.
        This recursion can be visualized as moving along the path from <var>n</var>
        to the blank node <var>n<sub>i</sub></var> that is receiving a temporary identifier.
        If, when recursing on <var>n<sub>i</sub></var>,
        another unlabeled blank node <var>n<sub>j</sub></var> is discovered,
        the algorithm again recurses.
        Such a recursion traces out the <a>gossip path</a> from <var>n</var>
        to <var>n<sub>j</sub></var> via <var>n<sub>i</sub></var>.</p>

      <p>The recursive hash <var>r(i)</var> is the <a>hash</a> returned from
        the completed recursion on the node <var>n<sub>i</sub></var>
        when computing <var>h<sub>N</sub>(n)</var>.
        Just as <var>h<sub>N</sub>(n)</var> is the hash of <var>D<sub>n</sub></var>,
        we denote the data to hash in the recursion on <var>n<sub>i</sub></var>
        as <var>D<sub>i</sub></var>.
        So, <var>r(i)</var> = <var>h(D<sub>i</sub>)</var>.
        For each related hash <var>x</var> ∈ <var>H<sub>n</sub></var>,
        <var>R<sub>n</sub>(x)</var> is called the <em>recursion list</em> on
        which the algorithm recurses.</p>
    </section>

    <section id="hash-nd-quads-examples" class="informative">
      <h3>Examples</h3>

      <p class="ednote">
        Add some examples ranging from simple to complicated and resource consuming.
      </p>

      <aside id="ex-nd-shared-hashes"
            class="example"
            title="Shared hashes">

        <p>This example revisits <a href="#ex-ca-shared-hashes"></a>
          to illustrate the operation of the
          <a href="#hash-nd-quads-algorithm">Hash N-Degree Quads Algorithm</a>
          on the blank nodes (`e0` and `e1`) which resulted in a shared result from the
          <a href="#hash-1d-quads-algorithm">Hash First Degree Quads Algorithm</a>.
          The other blank nodes (`e2` and `e3`) had unique
          hashes when processed by the
          <a href="#hash-1d-quads-algorithm">Hash N-Degree Quads Algorithm</a>,
          so that canonical identifiers have already been issued,
          as recorded in the <a>identifier issuer</a> instance.</p>

        <table id="ex-nd-shared-table-input-canon-mapping"
               class="hash-related numbered">
          <caption>Established canonical identifiers from <a>canonical issuer</a></caption>
          <thead><tr>
            <th><var>original</var></th>
            <th><var>canonical</var></th>
          </tr></thead>
          <tbody>
            <tr><td>`e2`</td><td>`c14n0`</td></tr>
            <tr><td>`e3`</td><td>`c14n1`</td></tr>
          </tbody>
        </table>

        <figure id="fig-nd-shared-hashes" style="text-align:center">
          <!-- Source for this file is at https://docs.google.com/drawings/d/1HWpz8S-PNaWi02-utF62HAMd_0b-AF_tHNSRRUQILbU -->
          <object data="shared-hashes.svg" style="width: 75%" type="image/svg+xml" aria-describedby="fig-nd-shared-hashes-alt">
            <p id="fig-nd-shared-hashes-alt">
              The image represents the graph described in
              <a href="#ex-nd-shared-hashes-input">
                the following code block
              </a>.</p>
          </object>
          <figcaption>An illustration of a graph resulting in shared hashes.<br/>
            Image available in
            <a href="shared-hashes.svg" title="SVG image of a graph resulting in shared hashes">
              <abbr title="Scalable Vector Graphics">SVG</abbr>
            </a>.</figcaption>
        </figure>
          
        <pre id="ex-nd-shared-hashes-input"
             data-transform="updateExample"
             title="Graph with blank nodes resulting in shared hashes">
          <!--
            :p :q ****_:e0**** .
            :p :q ****_:e1**** .
            ****_:e0**** :p _:e2 .
            ****_:e1**** :p _:e3 .
            _:e2 :r _:e3 .
          -->
        </pre>

        <p>The algorithm will be called twice, with each blank node
           which did not result in a unique hash
          from the <a href="#hash-1d-quads-algorithm">Hash First Degree Quads Algorithm</a>
          (`e0` and `e1`).
          The <a data-cite="INFRA#map-entry">map entry</a> for `e0` in the <a>blank node to quads map</a> results in the
          following quads:</p>

        <pre id="ex-nd-shared-hashes-e0-quads" data-transform="updateExample">
          <!--
            :p :q _:e0 .
            _:e0 :p _:e2 .
          -->
        </pre>

        <p>When called, the <var>temporary issuer</var> has the following mappings:</p>

        <table id="ex-nd-shared-table-input-temporary-mapping-e0"
               class="hash-related numbered">
          <caption>Initial mappings in <var>temporary issuer</var> for `e0`</caption>
          <thead><tr>
            <th><var>original</var></th>
            <th><var>canonical</var></th>
          </tr></thead>
          <tbody>
            <tr><td>`e0`</td><td>`b0`</td></tr>
          </tbody>
        </table>

        <p><a href="#hndq-3">Step 3</a> iterates over each of these quads
          to find <a>blank node</a> <var>components</var>
          to populate <var>H<sub>n</sub></var>
          with the result of running the
          <a href="#hash-related-blank-node">Hash Related Blank Node algorithm</a>
          using the <var>position</var> of that <var>component</var> within the quad.</p>

        <table id="ex-nd-shared-table-related-hash-e0"
               class="hash-related numbered">
          <caption>Hash for `e2`  related to `e0`</caption>
          <thead><tr>
            <th><var>related</var></th>
            <th><var>quad</var></th>
            <th><var>position</var></th>
            <th><var>hash</var></th>
          </tr></thead>
          <tbody>
            <tr>
              <td>`e2`</td>
              <td>`e0&nbsp;:p&nbsp;e2&nbsp;.`</td>
              <td>`o`</td>
              <td>
                <!-- canonical identifer _:e2 is _:c14n0 -->
                <!-- hash "o<http://example.com/#p>_:c14n0"-->
                <code><abbr title="29cf7e22790bc2ed395b81b3933e5329fc7b25390486085cac31ce7252ca60fa">29cf7e2279...7252ca60fa</abbr></code></td>
            </tr>
          </tbody>
        </table>

        <p>which results in the following <var>H<sub>n</sub></var>:</p>

        <table id="ex-nd-shared-table-bn-list-e0"
               class="hash-related numbered">
          <caption>Blank node list for hash</caption>
          <thead><tr>
            <th><var>related hash</var></th>
            <th><var>blank node list</var></th>
          </tr></thead>
          <tbody>
            <tr>
              <td><code>29cf7e22790bc2ed395b81b3933e5329fc7b25390486085cac31ce7252ca60fa</code></td>
              <td>`[ e2 ]`</td>
            </tr>
          </tbody>
        </table>

        <p><a href="#hndq-5">Step 5</a> iterates over each <var>related hash</var>
          which is a key in <var>H<sub>n</sub></var>,
          which can have one or more related blank nodes,
          which determines the shortest <a>gossip path</a> between
          the two nodes (`e0` and `e2`).
          In this case, the hash maps to just `e2`,
          for which a canonical identifier has already been chosen (`c14n0`),
          so there is a single permutation
          resulting in one candidate path.
          The resulting <var>chosen path</var> is `c14n0`.</p>

        <p>The string <var>data to hash</var> is composed
          of the single <var>related hash</var> and the <var>chosen path</var>:
          `29cf7e22790bc2ed395b81b3933e5329fc7b25390486085cac31ce7252ca60fac14n0`,
          which hashes to
          `fbc300de5afafd97a4b9ee1e72b57754dcdcb7ebb724789ac6a94a5b82a48d30`,
          which, along with the <var>temporary issuer</var> used to traverse
          these paths, is the result of the algorithm:</p>

        <table id="ex-nd-shared-result-e0"
               class="hash-related numbered">
          <caption>Result for `e0`</caption>
          <tbody>
            <tr>
              <td><var>temporary issuer</var> mappings</td>
              <td>
                <table class="hash-related">
                  <thead><tr>
                    <th><var>original</var></th>
                    <th><var>canonical</var></th>
                  </tr></thead>
                  <tbody>
                    <tr><td>`e0`</td><td>`b0`</td></tr>
                  </tbody>
                </table>
              </td>
            </tr>
            <tr>
              <td><var>hash</var></td>
              <td>`fbc300de5afafd97a4b9ee1e72b57754dcdcb7ebb724789ac6a94a5b82a48d30`</td>
            </tr>
          </tbody>
        </table>

        <p>The algorithm is called again for `e1`.</p>

        <table id="ex-nd-shared-table-input-temporary-mapping-e1"
               class="hash-related numbered">
          <caption>Initial mappings in <var>temporary issuer</var> for `e1`</caption>
          <thead><tr>
            <th><var>original</var></th>
            <th><var>canonical</var></th>
          </tr></thead>
          <tbody>
            <tr><td>`e1`</td><td>`b0`</td></tr>
          </tbody>
        </table>

        <p>The <a data-cite="INFRA#map-entry">map entry</a> for `e1` in the <a>blank node to quads map</a> results in the
          following quads:</p>

        <pre id="ex-nd-shared-hashes-e1-quads" data-transform="updateExample">
          <!--
            :p :q _:e1 .
            _:e1 :p _:e3 .
          -->
        </pre>

        <p><a href="#hndq-3">Step 3</a> again calculates <a>blank node</a> <var>components</var>
          using
          <a href="#hash-related-blank-node">Hash Related Blank Node algorithm</a>.</p>

        <table id="ex-nd-shared-table-related-hash-e1"
               class="hash-related numbered">
          <caption>Hash for `e3`  related to `e1`</caption>
          <thead><tr>
            <th><var>related</var></th>
            <th><var>quad</var></th>
            <th><var>position</var></th>
            <th><var>hash</var></th>
          </tr></thead>
          <tbody>
            <tr>
              <td>`e3`</td>
              <td>`e1&nbsp;:p&nbsp;e3&nbsp;.`</td>
              <td>`o`</td>
              <td>
                <!-- canonical identifer _:e3 is _:c14n1 -->
                <!-- hash "o<http://example.com/#p>_:c14n1"-->
                <code><abbr title="b7956ea1d654d5824496eb439a1f2b79478bd7d02d4a115f4c97cbff6b098216">b7956ea1d6...ff6b098216</abbr></code></td>
            </tr>
          </tbody>
        </table>

        <p>which results in the following <var>H<sub>n</sub></var>:</p>

        <table id="ex-nd-shared-table-bn-list-e1"
               class="hash-related numbered">
          <caption>Blank node list for hash</caption>
          <thead><tr>
            <th><var>related hash</var></th>
            <th><var>blank node list</var></th>
          </tr></thead>
          <tbody>
            <tr>
              <td><code>b7956ea1d654d5824496eb439a1f2b79478bd7d02d4a115f4c97cbff6b098216</code></td>
              <td>`[ e3 ]`</td>
            </tr>
          </tbody>
        </table>

        <p><a href="#hndq-5">Step 5</a>
          runs in essentially the same manner, mapping just `e3`
          having the canonical identifier `c14n1`,
          so there is again a single permutation
          resulting in one candidate path.
          The resulting <var>chosen path</var> is `c14n1`.</p>

        <p>The string <var>data to hash</var> is composed
          of the single <var>related hash</var> and the <var>chosen path</var>:
          `af54b9512b1ef069205e8e41bc5a96e86a108b0389caa5029f2c3fd0bc465246c14n1`,
          which hashes to
          `767a5e66f509221f45003a16c12a89d4d9675cfa51ffa80459b63606bdfc2ada`.</p>

        <p>The string <var>data to hash</var> is composed
          of the single <var>related hash</var> and the <var>chosen path</var>:
          `b7956ea1d654d5824496eb439a1f2b79478bd7d02d4a115f4c97cbff6b098216c14n1`,
          which hashes to
          `fbc300de5afafd97a4b9ee1e72b57754dcdcb7ebb724789ac6a94a5b82a48d30`,
          which, along with the <var>temporary issuer</var> used to traverse
          these paths, is the result of the algorithm:</p>

        <table id="ex-nd-shared-result-e1"
               class="hash-related numbered">
          <caption>Result for `e1`</caption>
          <tbody>
            <tr>
              <td><var>temporary issuer</var> mappings</td>
              <td>
                <table class="hash-related">
                  <thead><tr>
                    <th><var>original</var></th>
                    <th><var>canonical</var></th>
                  </tr></thead>
                  <tbody>
                    <tr><td>`e1`</td><td>`b0`</td></tr>
                  </tbody>
                </table>
              </td>
            </tr>
            <tr>
              <td><var>hash</var></td>
              <td>`2c0b377baf86f6c18fed4b0df6741290066e73c932861749b172d1e5560f5045`</td>
            </tr>
          </tbody>
        </table>
      </aside>
    </section>

    <section id="hash-nd-quads-algorithm">
      <h3>Algorithm</h3>

      <div class="issue" data-number="16">
        An additional input to this algorithm should be added that
        allows it to be optionally skipped and throw an error if any
        equivalent related hashes were produced that must be permuted
        during step 5.4.4. For practical uses of the algorithm, this step
        should never be encountered and could be turned off, disabling
        canonizing datasets that include a need to run it as a security
        measure.
      </div>

      <p>The inputs to this algorithm are the <a>canonicalization state</a>,
        the <var>identifier</var> for the <a>blank node</a> to
        recursively hash quads for, and path identifier <var>issuer</var> which is
        an <a>identifier issuer</a> that issues temporary
        <a>blank node identifier</a>s. The output from this algorithm
        will be a <a>hash</a> and the <a>identifier issuer</a> used
        to help generate it.</p>

      <ol>
        <li id="hndq-1">Create a new <a>map</a> <var>H<sub>n</sub></var>
          for relating hashes to related <a>blank nodes</a>.</li>
        <li id="hndq-2">Get a reference, <var>quads</var>, to the list of <a>quads</a>
          from the [= map/entry | map entry =]
          for <var>identifier</var>
          in the <a>blank node to quads map</a>.
          <details>
            <summary>Explanation</summary>
            <p><var>quads</var> is the <a>mention set</a> of <var>identifier</var>.</p>
          </details>
        </li>
        <li id="hndq-3">For each <var>quad</var> in <var>quads</var>:
          <details>
            <summary>Explanation</summary>
            <p>This loop calculates the related hash <var>H<sub>n</sub></var>
              for other blank nodes within the <a>mention set</a> of <var>identifier</var>.</p>
          </details>
          <ol>
            <li id="hndq-3-1">For each <var>component</var> in <var>quad</var>, where <var>component</var>
              is the <a>subject</a>, <a>object</a>, or
              <a>graph name</a>, and it is a
              <a>blank node</a> that is not identified by
              <var>identifier</var>:
              <ol>
                <li id="hndq-3-1-1">Set <var>hash</var> to the result of the
                  <a href="#hash-related-blank-node">Hash Related Blank Node algorithm</a>,
                  passing the <a>blank node identifier</a> for
                  <var>component</var> as <var>related</var>, <var>quad</var>,
                  <var>issuer</var>, and
                  <var>position</var> as either <code>s</code>, <code>o</code>, or
                  <code>g</code> based on whether <var>component</var> is a
                  <a>subject</a>, <a>object</a>,
                  <a>graph name</a>, respectively.</li>
                <li id="hndq-3-1-2">Add a mapping of <var>hash</var> to the
                  <a>blank node identifier</a> for <var>component</var>
                  to <var>H<sub>n</sub></var>, adding an entry
                  as necessary.</li>
              </ol>
            </li>
          </ol>
        </li>
        <li id="hndq-4">Create an empty string, <var>data to hash</var>.</li>
        <li id="hndq-5">For each <var>related hash</var> to <var>blank node list</var> mapping in
          <var>H<sub>n</sub></var>, <a>code point ordered</a>
          by <var>related hash</var>:
          <details>
            <summary>Explanation</summary>
            <p>This loop explores the <a>gossip paths</a> for each
              related blank node sharing a common hash to <var>identifier</var>
              finding the shortest such path (<var>chosen path</var>).
              This determines how canonical identifiers for
              otherwise commonly hashed blank nodes are chosen.
            </p>
            <p>
              Each path is represented by the concatenation of the
              identifiers for each related blank node
              – either the issued identifier,
              or a temporary identifier created using a copy of <var>issuer</var>.
              Those for which temporary identifiers were issued are later
              recursed over using this algorithm.
            </p>
          </details>
          <ol>
            <li id="hndq-5-1">Append the <var>related hash</var> to the <var>data to hash</var>.</li>
            <li id="hndq-5-2">Create a <a>string</a> <var>chosen path</var>.</li>
            <li id="hndq-5-3">Create an unset <var>chosen issuer</var> variable.</li>
            <li id="hndq-5-4">For each <a href="https://en.wikipedia.org/wiki/Permutation">permutation</a> <var>p</var> of <var>blank node list</var>:
              <ol>
                <li id="hndq-5-4-1">Create a copy of <var>issuer</var>, <var>issuer copy</var>.</li>
                <li id="hndq-5-4-2">Create a <a>string</a> <var>path</var>.</li>
                <li id="hndq-5-4-3">Create a <var>recursion list</var>, to store
                  <a>blank node identifiers</a> that must be
                  recursively processed by this algorithm.</li>
                <li id="hndq-5-4-4">For each <var>related</var> in <var>p</var>:
                  <ol>
                    <li id="hndq-5-4-4-1">If a canonical identifier has been issued for
                      <var>related</var> by <var>issuer</var>,
                      append it to <var>path</var>.</li>
                    <li id="hndq-5-4-4-2">Otherwise:
                      <ol>
                        <li id="hndq-5-4-4-2-1">If <i>issuer copy</i> has not issued
                          an identifier for <var>related</var>, append
                          <var>related</var> to <var>recursion list</var>.
                          <details>
                            <summary>Explanation</summary>
                            <p>Temporarily labeled nodes have identifiers recorded
                              in <var>issuer copy</var>,
                              which is later used to recursively call this algorithm,
                              so that eventually all nodes are given canonical identifiers.</p>
                          </details>
                        </li>
                        <li id="hndq-5-4-4-2-2">Use the
                          <a href="#issue-identifier">Issue Identifier algorithm</a>,
                          passing <var>issuer copy</var> and <var>related</var> and
                          append the result to <var>path</var>.</li>
                      </ol>
                    </li>
                    <li id="hndq-5-4-4-3">If <var>chosen path</var> is not empty and the length
                      of <var>path</var> is greater than or equal to the length
                      of <var>chosen path</var> and <var>path</var> is
                      greater than <var>chosen path</var> when
                      considering <a>code point order</a>,
                      then skip to the next
                      <a href="https://en.wikipedia.org/wiki/Permutation">permutation</a> <var>p</var>.
                      <details>
                        <summary>Explanation</summary>
                        <p>If <var>path</var> is already longer than
                          the prospective <var>chosen path</var>,
                          we can terminate this iteration early.</p>
                      </details>
                    </li>
                  </ol>
                </li>
                <li id="hndq-5-4-5">For each <var>related</var> in <var>recursion list</var>:
                  <details>
                    <summary>Explanation</summary>
                    <p>The propective <var>path</var> is extended with
                      the hash resulting from recursively calling this algorithm
                      on each related blank node issued a temporary identifier.</p>
                  </details>
                  <ol>
                    <li id="hndq-5-4-5-1">Set <var>result</var> to the result of recursively executing
                      the
                      <a href="#hash-nd-quads">Hash N-Degree Quads algorithm</a>,
                      passing <var>related</var> for <var>identifier</var> and
                      <var>issuer copy</var> for <var>path identifier issuer</var>.</li>
                    <li id="hndq-5-4-5-2">Use the
                      <a href="#issue-identifier">Issue Identifier algorithm</a>,
                      passing <var>issuer copy</var> and <var>related</var> and
                      append the result to <var>path</var>.</li>
                    <li id="hndq-5-4-5-3">Append <code>&lt;</code>, the <a>hash</a> in
                      <var>result</var>, and <code>&gt;</code> to <var>path</var>.</li>
                    <li id="hndq-5-4-5-4">Set <var>issuer copy</var> to the
                      <a>identifier issuer</a> in result.</li>
                    <li id="hndq-5-4-5-5">If <var>chosen path</var> is not empty and the length
                      of <var>path</var> is greater than or equal to the length
                      of <var>chosen path</var> and <var>path</var> is
                      greater than <var>chosen path</var> when considering <a>code point order</a>,
                      then skip to the next <var>p</var>.
                      <details>
                        <summary>Explanation</summary>
                        <p>If <var>path</var> is already longer than
                          the prospective <var>chosen path</var>,
                          we can terminate this iteration early.</p>
                      </details>
                    </li>
                  </ol>
                </li>
                <li id="hndq-5-4-6">If <var>chosen path</var> is empty or <var>path</var> is
                  less than <var>chosen path</var> when considering <a>code point order</a>,
                  set <var>chosen path</var> to <var>path</var> and <var>chosen issuer</var>
                  to <var>issuer copy</var>.</li>
              </ol>
            </li>
            <li id="hndq-5-5">Append <var>chosen path</var> to <var>data to hash</var>.</li>
            <li id="hndq-5-6">Replace <var>issuer</var>, by reference, with
              <var>chosen issuer</var>.</li>
          </ol>
        </li>
        <li id="hndq-6">Return <var>issuer</var> and the <a>hash</a> that results from
          passing <var>data to hash</var> through the
          <a>hash algorithm</a>.</li>
      </ol>
    </section>
  </section>
</section>

<section id="privacy-considerations">
  <h2>Privacy Considerations</h2>

  <p class="ednote">TBD</p>
</section>

<section id="security-considerations">
  <h2>Security Considerations</h2>

  <p class="ednote">TBD</p>
</section>

<section id="use-cases" class="informative">
  <h2>Use Cases</h2>
  <p class="ednote">TBD</p>
</section>

<section id="examples" class="informative">
  <h2>Examples</h2>
  <p class="ednote">TBD</p>
</section>

<section id="urgna2021" class="appendix informative algorithm">
  <h2>URGNA2012</h2>
  <p>A previous version of this algorithm has light deployment. For purposes of identification,
    the algorithm is called the
    "Universal RDF Graph Canonicalization Algorithm 2012"
    (<abbr title="Universal RDF Graph Canonicalization Algorithm 2012"><dfn class="export">URGNA2012</dfn></abbr>),
    and differs from the stated algorithm in the following ways:</p>
  <ul>
    <li>In <a href="#hash-1d-quads" class="sectionRef"></a>, if any blank node was used in the <a>graph name</a>
      position in the <a>quad</a>, then the value was serialized using
      the special <a>blank node identifier</a>, <code>g</code>, instead of <code>z</code>.</li>
    <li>In <a href="#hash-related-blank-node" class="sectionRef"></a>, value of the <a>predicate</a>
      was not delimited by <code>&lt;</code> and <code>&gt;</code>; there
      were no delimiters.</li>
    <li>In <a href="#hash-nd-quads" class="sectionRef"></a>, the <var>position</var> parameter passed to
      the <a href="#hash-related-blank-node">Hash Related Blank Node algorithm</a>
      was instead modeled as a <var>direction</var> parameter, where it could have
      the value <code>p</code>, for property, when the related blank node was a
      <a>subject</a> and the value <code>r</code>, for reverse or reference, when
      the related blank node was an <a>object</a>. Since <a>URGNA2012</a> only normalized
      graphs, not datasets, there was no use of the <a>graph name</a> position.</li>
    <li>In <a href="#hash-nd-quads" class="sectionRef"></a>, building the
      <var>H<sub>n</sub></var> was done as follows:
      <ol>
        <li id="urgna-1">For each <var>quad</var> in <var>quads</var>:
          <ol>
            <li id="urgna-1-1">If the <var>quad</var>'s <a>subject</a> is a <a>blank node</a> that does not
              match <var>identifier</var>, set <var>hash</var> to the result of the
                <a href="#hash-related-blank-node">Hash Related Blank Node algorithm</a>,
                passing the <a>blank node identifier</a> for
                <a>subject</a> as <var>related</var>, <var>quad</var>,
                <var>issuer</var>, and
                <code>p</code> as <var>position</var>.
            </li>
            <li id="urgna-1-2">Otherwise, if <var>quad</var>'s <a>object</a> is a <a>blank node</a> that does
              not match <var>identifier</var>, set <var>hash</var> to the result of the
                <a href="#hash-related-blank-node">Hash Related Blank Node algorithm</a>,
                passing the <a>blank node identifier</a> for
                <a>object</a> as <var>related</var>, <var>quad</var>,
                <var>issuer</var>, and
                <code>r</code> as <var>position</var>.
            </li>
            <li id="urgna-1-3">Otherwise, continue to the next quad.</li>
            <li id="urgna-1-4">Add a mapping of <var>hash</var> to the
              <a>blank node identifier</a> for the component
              that matched (<a>subject</a> or <a>object</a>) to
              <var>H<sub>n</sub></var>, adding an entry
              as necessary.</li>
          </ol>
        </li>
      </ol>
    </li>
  </ul>
</section>

<section id="index"></section>

<section class="appendix informative" id="changes-from-fpwd">
  <h2>Changes since the First Public Working Draft of 24 November 2022</h2>
  <ul>
    <li>
      The algorithm, and the examples, have been changed to systematically
      use the `xyz` format for blank node identifiers, instead of
      `_:xyz`. See <a href="https://github.com/w3c/rdf-canon/issues/46">Issue 46</a> 
      for the discussion
    </li>
    <li>
      <a href="#hash-1d-quads" class="sectionRef"></a>
      was simplified to remove the `simple` flag,
      which was unused in existing implementations.
      The original design of the algorithm was to use the
      assigned canonical <a>blank node identifier</a>,
      if available, instead of `_:a` or `_:z`,
      similar to how it is used in
      the related hash algorithm, but this text never made it into the spec
      before implementations moved forward.
      Therefore, the hashes never change,
      making the loop based on the `simple`
      flag that calls this algorithm unnecessary.
      See <a href="https://github.com/w3c/rdf-canon/issues/23">Issue 23</a> for the discussion.
    </li>

    <li>Add definition for <a>canonical n-quads form</a>. Eventually, this should
      be a citation from [[N-Quads]], when it is updated.
      <a>Canonical n-quads form</a> is used in <a href="#hash-1d-quads" class="sectionRef"></a>.
    </li>

    <li>Removed issue marker for
      <a href="https://github.com/w3c/rdf-canon/issues/15">Issue 15</a>
      in <a href="#canon-algorithm" class="sectionRef"></a>,
      adding a note that
      <a data-cite="RDF11-CONCEPTS#dfn-literal">literal</a>
      components of <a>quads</a> are not normalized,
      and two literals with different syntactic representations
      remain distinct resources.</li>
  </ul>
</section>

<section id="ack" class="appendix informative">
  <h2>Acknowledgements</h2>

  <p>The editors would like to thank Jeremy Carroll for his work on the
    graph canonicalization problem, Gavin Carothers for providing valuable
    feedback and testing input for the algorithm defined in this
    specification, Sir Tim Berners Lee for his thoughts on graph canonicalization
    over the years, Jesús Arias Fisteus for his work on a similar
    algorithm.</p>

  <p class="ednote">Acknowledge CCG and RCH WG. Consider using `.publ_ack.json`.</p>
        <div class="issue" data-number="19"></div>
</section>

</body>
</html>
